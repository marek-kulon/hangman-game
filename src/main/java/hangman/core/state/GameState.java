package hangman.core.state;

import hangman.core.guess.Guess;
import hangman.core.secret.Secret;
import org.apache.commons.lang3.Validate;

import java.io.Serializable;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import static hangman.core.Game.GameStatus;
import static hangman.core.Game.GameStatus.*;

/**
 * Immutable game state
 *
 * @author Marek Kulon
 *
 */
public final class GameState implements Serializable {
	private static final long serialVersionUID = 1L;
	
	/** Maximum number of incorrect guesses  */
	private final int maxIncorrectGuessesNo;
	/** Secret word to guess */
	private final Secret secret;
	/** All guesses user has made so far */
	private final Set<Guess> guesses;
	
	/**
	 * 
	 * @param maxIncorrectGuessesNo
	 * @param secret
	 * @param guesses
	 * @return
	 */
	public static GameState newGameState(int maxIncorrectGuessesNo, Secret secret, Set<Guess> guesses) {
		Validate.isTrue(maxIncorrectGuessesNo >= 0);
		Validate.notNull(secret);
		Validate.noNullElements(guesses);
		
		return new GameState(maxIncorrectGuessesNo,
				secret,
				guesses);
	}

	/**
	 * 
	 * @param oldGameState
	 * @param value
	 * @return
	 * @throws GuessAlreadyMadeException
	 */
	public static GameState newGameStateWithGuess(GameState oldGameState, Guess value) {
		Validate.notNull(oldGameState);
		Validate.notNull(value);

		if (oldGameState.isGuessedAlready(value)) {
			throw new GuessAlreadyMadeException(value);
		}

		Set<Guess> newGuesses = new HashSet<>();
		newGuesses.addAll(oldGameState.getGuesses());
		newGuesses.add(value);

		return new GameState(
				oldGameState.getMaxIncorrectGuessesNo(),
				oldGameState.getSecret(),
				newGuesses);
	}
	
	/**
	 * @return number of right guesses made by user
	 */
	public int getCorrectGuessesNo() {
		int correctGuessesNo = 0;
		for(Guess guess : getGuesses()) {
			correctGuessesNo += guess.isCorrectFor(getSecret()) ? 1 : 0;
		}
		return correctGuessesNo;
	}
	
	/**
	 * @return number of wrong guesses made by user
	 */
	public int getIncorrectGuessesNo() {
		return guesses.size() - getCorrectGuessesNo();
	}
	
	
	/**
	 * Calculate status/progress of the game based on its current state
	 * 
	 * @return
	 */
	public GameStatus getGameStatus() {
        final int incorrectGuessesNo = getIncorrectGuessesNo();

		// users incorrect guesses number >= maximum value
		if (incorrectGuessesNo > 0 && incorrectGuessesNo >= getMaxIncorrectGuessesNo()) {
			return LOST;
		}
		// number of correct guesses made by user == number of guesses it takes to know the secret
		if (getCorrectGuessesNo() == getSecret().getGuessesToKnowMeNo()) {
			return WON;
		}
		// otherwise
		return IN_PROGRESS;
	}
	
	
	/*
	 *  Private constructor
	 *  Set of guesses is unmodifiable. Better solution would be 
	 *  a set collection without 'add', 'remove', 'clear' methods in its API
	 */
	private GameState(int maxIncorrectGuessesNo, Secret secret, Set<Guess> guesses) {
		this.maxIncorrectGuessesNo = maxIncorrectGuessesNo;
		this.secret = secret;
		this.guesses = Collections.unmodifiableSet(guesses); // make sure is immutable
		
		// post construct: validate incorrect guesses number in relation to maximum allowed value
		if (getMaxIncorrectGuessesNo()!=0 && getIncorrectGuessesNo() > getMaxIncorrectGuessesNo()) {
			throw new IllegalGameStateException("Number of incorrect guesses is grater than maximum allowed value");
		}
	}

	public int getMaxIncorrectGuessesNo() {
		return maxIncorrectGuessesNo;
	}

	public Secret getSecret() { // todo: secret is immutable but new copying here wouldn't hurt (changes?)
		return secret;
	}

	public Set<Guess> getGuesses() {
		return guesses;
	}
	
	private boolean isGuessedAlready(Guess value) {
		return getGuesses().contains(value);
	}
	
	
	/*
	 * equals & hashCode generated by eclipse 
	 */

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((guesses == null) ? 0 : guesses.hashCode());
		result = prime * result + maxIncorrectGuessesNo;
		result = prime * result + ((secret == null) ? 0 : secret.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		GameState other = (GameState) obj;
		if (guesses == null) {
			if (other.guesses != null)
				return false;
		} else if (!guesses.equals(other.guesses))
			return false;
		if (maxIncorrectGuessesNo != other.maxIncorrectGuessesNo)
			return false;
		if (secret == null) {
			if (other.secret != null)
				return false;
		} else if (!secret.equals(other.secret))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "GameState [maxIncorrectGuessesNo=" + maxIncorrectGuessesNo
				+ ", secret=" + secret + ", guesses=" + guesses + "]";
	}
}
